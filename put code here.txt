public class ChameleonCritter
{
private static final double DARKENING_FACTOR = 0.05;

//Use the code found in the Flower class to darken a ChameleonCritter when it has no neighbors.
//This code has been put in a method, darken.
/**
 * Randomly selects a neighbor and changes this critter's color to be the
 * same as that neighbor's. If there are no neighbors, no action is taken.
 */
public void processActors(ArrayList<Actor> actors)
{
 int n = actors.size();
 if (n == 0)
 {
 darken();
 return;
 }

 int r = (int) (Math.random() * n);
 Actor other = actors.get(r);
 setColor(other.getColor());
}

/**
 * Darkens this critter's color by DARKENING_FACTOR.
 */
private void darken()
{
 Color c = getColor();
 int red = (int) (c.getRed() * (1 - DARKENING_FACTOR));
 int green = (int) (c.getGreen() * (1 - DARKENING_FACTOR));
 int blue = (int) (c.getBlue() * (1 - DARKENING_FACTOR));
 setColor(new Color(red, green, blue)); 
 }
}

import info.gridworld.actor.Actor;
import info.gridworld.actor.Critter;
import info.gridworld.actor.Flower;
import info.gridworld.grid.Location;
import info.gridworld.grid.Grid;
import java.util.ArrayList;
/**
 * A <code>ChameleonKid</code> takes on the color of neighboring actors
 * that are in front or behind as it moves through the grid. <br />
 */
public class ChameleonKid extends ChameleonCritter
{
 /**
 * Gets the actors for processing. The actors must be contained in the
 * same grid as this critter. Implemented to return the actors that
 * occupy neighboring grid locations in front or behind this critter.
 * @return a list of actors that are neighbors of this critter
 */
 public ArrayList<Actor> getActors()
 {
 ArrayList<Actor> actors = new ArrayList<Actor>();
 int[] dirs =
 { Location.AHEAD, Location.HALF_CIRCLE };
 for (Location loc : getLocationsInDirections(dirs))
 {
 Actor a = getGrid().get(loc);
 if (a != null)
 actors.add(a);
 }
 return actors;
 } 
 /**
 * Finds the valid adjacent locations of this critter in different
 * directions.
 * @param directions - an array of directions (which are relative to the
 * current direction)
 * @return a set of valid locations that are neighbors of the current
 * location in the given directions
 */
 public ArrayList<Location> getLocationsInDirections(int[] directions)
 {
 ArrayList<Location> locs = new ArrayList<Location>();
 Grid gr = getGrid();
 Location loc = getLocation();

 for (int d : directions)
 {
 Location neighborLoc = loc.getAdjacentLocation(getDirection() + d);
 if (gr.isValid(neighborLoc))
 locs.add(neighborLoc);
 }
 return locs;
 }
} 

import info.gridworld.actor.Actor;
import info.gridworld.actor.Rock;
import info.gridworld.actor.Critter;
import info.gridworld.grid.Location;
import java.util.ArrayList;
public class RockHound extends Critter
{
 /**
 * Processes the actors. Implemented to "eat" (i.e. remove) all rocks
 * <br />
 * Precondition: All objects in <code>actors</code> are contained in the
 * same grid as this critter.
 * @param actors the actors to be processed
 */
 public void processActors(ArrayList<Actor> actors)
 {
 for (Actor a : actors)
 {
 if (a instanceof Rock)
 a.removeSelfFromGrid();
 }
 }
} 

import info.gridworld.actor.Actor;
import info.gridworld.actor.Critter;
import info.gridworld.grid.Grid;
import info.gridworld.grid.Location;
import java.awt.Color;
import java.util.ArrayList;
/**
 * A <code>QuickCrab</code> looks at a limited set of neighbors when it
 * eats and moves.<br />
 */
public class QuickCrab extends CrabCritter
{
 public QuickCrab()
 {
 setColor(Color.CYAN);
 } 
  /**
 * @return list of empty locations
 * two locations to the right and two locations to the left
 */
 public ArrayList<Location> getMoveLocations()
 {
 ArrayList<Location> locs = new ArrayList<Location>();
 Grid g = getGrid();

 addIfGoodTwoAwayMove(locs,getDirection() + Location.LEFT);
 addIfGoodTwoAwayMove(locs,getDirection() + Location.RIGHT);

 if (locs.size() == 0)
 return super.getMoveLocations();

 return locs;
 }

 /**
 * Adds a valid and empty two away location in direction dir to the
 * ArrayList locs.
 * To be a valid two away location, the location that is one away in
 * direction dir must also be valid and empty.
 */
 private void addIfGoodTwoAwayMove(ArrayList<Location> locs,int dir)
 {
 Grid g = getGrid();
 Location loc = getLocation();

 Location temp = loc.getAdjacentLocation(dir);

 if(g.isValid(temp) && g.get(temp) == null)
 {
 Location loc2 = temp.getAdjacentLocation(dir);
 if(g.isValid(loc2) && g.get(loc2)== null)
 locs.add(loc2);
 }
 }

} 

import info.gridworld.actor.Actor;
import info.gridworld.actor.Critter;
import info.gridworld.grid.Grid;
import info.gridworld.grid.Location;
import java.awt.Color;
import java.util.ArrayList;
/**
 * A <code>KingCrab</code> looks at a limited set of neighbors when it
 * eats and moves.<br />
 */
public class KingCrab extends CrabCritter
{
 public KingCrab()
 {
 setColor(Color.PINK);
 }

 /**
 * Computes the rounded integer distance between two given locations.
 */
 public int distanceFrom(Location loc1, Location loc2)
 {
 int x1 = loc1.getRow();
 int y1 = loc1.getCol();
 int x2 = loc2.getRow();
 int y2 = loc2.getCol();
 double dist = Math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2)) + .5;
 return (int)Math.floor(dist);
 } 
 /*
 * This method moves the Actor to a location that is one location
 * further away from this KingCrab and returns true. If there is no
 * location that is one location further away, the method returns false.
 */
 private boolean moveOneMoreAway(Actor a)
 {
 ArrayList<Location> locs =
 getGrid().getEmptyAdjacentLocations(a.getLocation());

 for(Location loc:locs)
 {
 if(distanceFrom(getLocation(), loc) > 1)
 {
 a.moveTo(loc);
 return true;
 }
 }

 return false;
 }

 /*
 * Each actor in the list actors is told to move one location further
 * away from this KingCrab. If that is not possible, the actor is
 * removed from the grid.
 */
 public void processActors(ArrayList<Actor> actors)
 {
 for (Actor a : actors)
 {
 if (!moveOneMoreAway(a))
 {
 a.removeSelfFromGrid();
 }
 }
 }
}
